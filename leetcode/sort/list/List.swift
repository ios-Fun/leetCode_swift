//
//  List.swift
//  leetcode
//
//  Created by youzhuo wang on 2020/4/13.
//  Copyright © 2020 youzhuo wang. All rights reserved.
//

import Foundation

// swift的数组是如何扩容的
// 数组的优缺点：访问快，新增和删除慢。物理空间要连续

// 链表：物理空间不用连续，访问慢，新增和删除快

// 跳表：解决顺序链表的查找，用空间换时间

// 静态链表：采用数组和链表的优点

// 循环链表：环

// 双向链表

// 双向循环链表

// 栈（stack）：先进后出

// 队列（queue）: 先进先出

// 十字链表？

// 矩阵

// 广义表

// 广义表的长度和深度

// 广义表的复制

// 线索二叉树

// 双向线索二叉树

// 回溯法：八皇后，移动迷宫

// 动态内存管理机制

// 边界标识法管理动态内存

// 查找
// 二分查找
// 分块查找
// 静态树表查找
// 二叉排序树查找
// 平衡二叉树（AVL树）:时间复杂度logN
// 红黑树：时间复杂度lgN

// 哈希表--散列函数
// 冲突的处理方法
// 开放寻址(定址)法：
// 1-1. 线性探测法；往右每次+1
// 1-2. 二次探测法；
// 1-3. 伪随机数探测法
// 2: 再哈希法，使用另一个哈希函数计算，直到冲突不再发生
// 3: 链地址法（java的hashmap）
// 4: 建立公共溢出区法
// 装填因子: 数据的个数 / 哈希表的长度
// 常见的hash算法： MD5, SHA1, SHA2-256
// 处理线程安全，rehash时避免死锁， 出现了环形链表， 如何处理？

// 如何动态扩容？
// 1. 新表，旧表 ---- 插入元素时转移桶元素
// 2. 一次扩容，所有元素重新hash

//开放寻址法优缺点：
//优点： 将数据存储在数组中，利用CPU缓存加快查询速度，并且序列化简答
//缺点：删除数据麻烦，需要特殊标记已删除的数据；需要将所有数据存储在一个连续的存储空间中，比起链表来说，冲突的代价更高
//使用场景：数据量小，装载因子小的时候采用

//链表法优缺点：
//优点：不用大量的连续内存；对装载因子的容忍度高；删除元素方便；
//缺点：链表存储指针，占据了内存空间；查询效率低
//使用场景：存储大对象、数据量大的散列表；


// 排序---几种排序的优缺点？
// 1. 插入排序
// 2. 折半排序
// 3. 2-路插入排序
// 4. 表插入排序
// 5. 希尔排序
// 6. 冒泡排序
// 7. 快速排序（最常用）,O(nlogn)
// 8. 简单选择排序，树形选择排序，堆排序, 最坏情况下也是O(nlogn)
// 9. 归并排序，O(nlogn)，当记录表中含有值相同的记录时，排序前和排序后在表中的相对位置不会改变。而堆排序和快速排序都是不稳定的。
// 10. 桶排序，基数排序
